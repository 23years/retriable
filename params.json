{"name":"Retriable","tagline":"Retriable is an simple DSL to retry code when an exception is raised. This is especially useful when interacting external api/services or file system calls.","body":"#Retriable\r\n\r\n[![Build Status](https://secure.travis-ci.org/kamui/retriable.png)](http://travis-ci.org/kamui/retriable)\r\n\r\nRetriable is an simple DSL to retry a code block if an exception should be raised.  This is especially useful when interacting external api/services or file system calls.\r\n\r\n##Installation\r\n\r\nvia command line:\r\n\r\n```ruby\r\ngem install retriable\r\n```\r\n\r\nIn your ruby script:\r\n\r\n```ruby\r\nrequire 'retriable'\r\n```\r\n\r\nIn your Gemfile:\r\n\r\n```ruby\r\ngem 'retriable'\r\n```\r\n\r\n##Usage\r\n\r\nCode in a retriable block will be retried if an exception is raised. By default, Retriable will rescue any exception inherited from `StandardError` (and `Timeout::Error`, which does not inherit from `StandardError` in ruby 1.8) and make 3 retry attempts before raising the last exception.\r\n\r\n```ruby\r\nrequire 'retriable'\r\n\r\nclass Api\r\n  # Use it in methods that interact with unreliable services\r\n  def get\r\n    Retriable.retriable do\r\n      # code here...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n###Options\r\n\r\nHere are the available options:\r\n\r\n`tries` (default: 3) - Number of attempts to make at running your code block\r\n\r\n`interval` (default: 0) - Number of seconds to sleep between attempts\r\n\r\n`timeout` (default: 0) - Number of seconds to allow the code block to run before raising a Timeout::Error\r\n\r\n`on` (default: [StandardError, Timeout::Error]) - `StandardError` and `Timeout::Error` or array of exceptions to rescue for each attempt\r\n\r\n`on_retry` - (default: nil) - Proc to call after each attempt is rescued\r\n\r\nYou can pass options via an options `Hash`. This example will only retry on a `Timeout::Error`, retry 3 times and sleep for a full second before each attempt.\r\n\r\n```ruby\r\nRetriable.retriable :on => Timeout::Error, :tries => 3, :interval => 1 do\r\n  # code here...\r\nend\r\n```\r\n\r\nYou can also specify multiple errors to retry on by passing an array of exceptions.\r\n\r\n```ruby\r\nRetriable.retriable :on => [Timeout::Error, Errno::ECONNRESET] do\r\n  # code here...\r\nend\r\n```\r\n\r\nYou can also specify a timeout if you want the code block to only make an attempt for X amount of seconds. This timeout is per attempt.\r\n\r\n```ruby\r\nRetriable.retriable :timeout => 1 do\r\n  # code here...\r\nend\r\n```\r\n\r\nIf you need millisecond units of time for the sleep or the timeout:\r\n\r\n```ruby\r\nRetriable.retriable :interval => (200/1000.0), :timeout => (500/1000.0) do\r\n  # code here...\r\nend\r\n```\r\n\r\n###Exponential Backoff\r\n\r\nIf you'd like exponential backoff, interval can take a Proc\r\n\r\n```ruby\r\n# with exponential back-off - sleep 4, 16, 64, 256, give up\r\nRetriable.retryable :times => 4, :interval => lambda {|attempts| 4 ** attempts} do\r\n  # code here...\r\nend\r\n```\r\n###Callbacks\r\n\r\nRetriable also provides a callback called `:on_retry` that will run after an exception is rescued. This callback provides the number of `tries`, and the `exception` that was raised in the current attempt. As these are specified in a `Proc`, unnecessary variables can be left out of the parameter list.\r\n\r\n```ruby\r\ndo_this_on_each_retry = Proc.new do |exception, tries|\r\n  log \"#{exception.class}: '#{exception.message}' - #{tries} attempts.\"}\r\nend\r\n\r\nRetriable.retriable :on_retry => do_this_on_each_retry do\r\n  # code here...\r\nend\r\n```\r\n\r\n###Ensure/Else\r\n\r\nWhat if I want to execute a code block at the end, whether or not an exception was rescued ([ensure](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-ensure))? Or, what if I want to execute a code block if no exception is raised ([else](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-else))? Instead of providing more callbacks, I recommend you just wrap retriable in a begin/retry/else/ensure block:\r\n\r\n```ruby\r\nbegin\r\n  Retriable.retriable do\r\n    # some code\r\n  end\r\nrescue => e\r\n  # run this if retriable ends up re-rasing the exception\r\nelse\r\n  # run this if retriable doesn't raise any exceptions\r\nensure\r\n  # run this no matter what, exception or no exception\r\nend\r\n```\r\n\r\n##Kernel Extension\r\n\r\nIf you want to call `Retriable.retriable` without the `Retriable` module prefix and you don't mind extending `Kernel`,\r\nthere is a kernel extension available for this.\r\n\r\nIn your ruby script:\r\n\r\n```ruby\r\nrequire 'retriable/core_ext/kernel'\r\n```\r\n\r\nor in your Gemfile:\r\n\r\n```ruby\r\ngem 'retriable', require: 'retriable/core_ext/kernel'\r\n```\r\n\r\nand then you can call `retriable` in any context like this:\r\n\r\n```ruby\r\nretriable do\r\n  # code here...\r\nend\r\n```\r\n\r\n##Credits\r\n\r\nRetriable was originally forked from the retryable-rb gem by [Robert Sosinski](https://github.com/robertsosinski), which in turn originally inspired by code written by [Michael Celona](http://github.com/mcelona) and later assisted by [David Malin](http://github.com/dmalin). The [attempt](https://rubygems.org/gems/attempt) gem by Daniel J. Berger was also an inspiration.\r\n","google":"UA-18119942-1","note":"Don't delete this file! It's used internally to help with page regeneration."}