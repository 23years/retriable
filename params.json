{"name":"Retriable","tagline":"Retriable is an simple DSL to retry failed code blocks with randomized exponential backoff.","body":"#Retriable\r\n\r\n[![Build Status](https://secure.travis-ci.org/kamui/retriable.png)](http://travis-ci.org/kamui/retriable)\r\n\r\nRetriable is an simple DSL to retry failed code blocks with randomized [exponential backoff](http://en.wikipedia.org/wiki/Exponential_backoff) time intervals. This is especially useful when interacting external api/services or file system calls.\r\n\r\n## Requirements\r\n\r\nRuby 2.0+\r\n\r\nIf you need 1.9.x support, use the [1.x branch](https://github.com/kamui/retriable/tree/1.x).\r\n\r\nWARNING: 2.x isn't API compatible with 1.x.\r\n\r\n## Installation\r\n\r\nvia command line:\r\n\r\n```ruby\r\ngem install retriable\r\n```\r\n\r\nIn your ruby script:\r\n\r\n```ruby\r\nrequire 'retriable'\r\n```\r\n\r\nIn your Gemfile:\r\n\r\n```ruby\r\ngem 'retriable', '~> 2.0'\r\n```\r\n\r\n## Usage\r\n\r\nCode in a `Retriable.retriable` block will be retried if an exception is raised. By default, Retriable will rescue any exception inherited from `StandardError`, make 3 retry tries before raising the last exception, and also use randomized exponential backoff to calculate each succeeding try interval. The default interval table with 10 tries looks like this (in seconds):\r\n\r\n| request# | retry interval | randomized interval             |\r\n| -------- | -------------- | ------------------------------- |\r\n| 1        |    0.5         |  [0.25,   0.75]                 |\r\n| 2        |    0.75        |  [0.375,  1.125]                |\r\n| 3        |    1.125       |  [0.5625,  1.6875]              |\r\n| 4        |    1.6875      |  [0.84375, 2.53125]             |\r\n| 5        |    2.53125     |  [1.265625, 3.796875]           |\r\n| 6        |    3.796875    |  [1.8984375,  5.6953125]        |\r\n| 7        |    5.6953125   |  [2.84765625,  8.54296875]      |\r\n| 8        |   8.54296875   |  [4.271484375, 12.814453125]    |\r\n| 9        |  12.814453125  |  [6.4072265625, 19.2216796875]  |\r\n| 10       | 19.2216796875  |  stop                           |\r\n\r\n```ruby\r\nrequire 'retriable'\r\n\r\nclass Api\r\n  # Use it in methods that interact with unreliable services\r\n  def get\r\n    Retriable.retriable do\r\n      # code here...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Options\r\n\r\nHere are the available options:\r\n\r\n`tries` (default: 3) - Number of tries to make at running your code block.\r\n\r\n`base_interval` (default: 0.5) - The initial interval in seconds between tries.\r\n\r\n`max_interval` (default: 60) - The maximum interval in seconds that any try can reach.\r\n\r\n`rand_factor` (default: 0.25) - The percent range above and below the next interval is randomized between. The calculation is calculated like this:\r\n\r\n```\r\nrandomized_interval = retry_interval * (random value in range [1 - randomization_factor, 1 + randomization_factor])\r\n```\r\n\r\n`multiplier` (default: 1.5) - Each successive interval grows by this factor. A multipler of 1.5 means the next interval will be 1.5x the current interval.\r\n\r\n`max_elapsed_time`  (default: 900 (15 min)) - The maximum amount of total time that code is allowed to keep being retried.\r\n\r\n`intervals`  (default: nil) - Skip generated intervals and provide your own array of intervals in seconds. Setting this option will ignore `tries`, `base_interval`, `max_interval`, `rand_factor`, and `multiplier` values.\r\n\r\n`timeout` (default: 0) - Number of seconds to allow the code block to run before raising a Timeout::Error\r\n\r\n`on` (default: [StandardError]) - An `Array` of exceptions to rescue for each try, a `Hash` where the keys are `Exception` classes and the values can be a single `Regexp` pattern or a list of patterns, or a single `Exception` type.\r\n\r\n`on_retry` - (default: nil) - Proc to call after each try is rescued.\r\n\r\n### Config\r\n\r\nYou can change the global defaults with a `#configure` block:\r\n\r\n```ruby\r\nRetriable.configure do |c|\r\n  c.tries = 5\r\n  c.max_elapsed_time = 3600 # 1 hour\r\nend\r\n```\r\n\r\n### Examples\r\n\r\n`Retriable.retriable` accepts custom arguments. This example will only retry on a `Timeout::Error`, retry 3 times and sleep for a full second before each try.\r\n\r\n```ruby\r\nRetriable.retriable on: Timeout::Error, tries: 3, base_interval: 1 do\r\n  # code here...\r\nend\r\n```\r\n\r\nYou can also specify multiple errors to retry on by passing an array of exceptions.\r\n\r\n```ruby\r\nRetriable.retriable on: [Timeout::Error, Errno::ECONNRESET] do\r\n  # code here...\r\nend\r\n```\r\n\r\nYou can also specify a Hash of exceptions where the values are a list or single Regexp pattern.\r\n\r\n```ruby\r\nRetriable.retriable on: {\r\n  ActiveRecord::RecordNotUnique => nil,\r\n  ActiveRecord::RecordInvalid => [/Email has already been taken/, /Username has already been taken/],\r\n  Mysql2::Error => /Duplicate entry/\r\n} do\r\n  # code here...\r\nend\r\n```\r\n\r\nYou can also specify a timeout if you want the code block to only make an try for X amount of seconds. This timeout is per try.\r\n\r\n```ruby\r\nRetriable.retriable timeout: 60 do\r\n  # code here...\r\nend\r\n```\r\n\r\nIf you need millisecond units of time for the sleep or the timeout:\r\n\r\n```ruby\r\nRetriable.retriable base_interval: (200/1000.0), timeout: (500/1000.0) do\r\n  # code here...\r\nend\r\n```\r\n\r\n### Custom Interval Array\r\n\r\nYou can also bypass the built-in interval generation and provide your own array of intervals. Supplying your own intervals overrides the `tries`, `base_interval`, `max_interval`, `rand_factor`, and `multiplier` parameters.\r\n\r\n```ruby\r\nRetriable.retriable intervals: [0.5, 1.0, 2.0, 2.5] do\r\n  # code here...\r\nend\r\n```\r\n\r\n### Turn off Exponential Backoff\r\n\r\nExponential backoff is enabled by default, if you want to simply execute code every second, you can do this:\r\n\r\n```ruby\r\nRetriable.retriable base_interval: 1.0, multiplier: 1.0, rand_factor: 0.0 do\r\n  # code here...\r\nend\r\n```\r\n\r\nIf you don't want exponential backoff, but you still want some randomization between intervals, this code will run every 1 seconds with a randomization factor of 0.2, which means each interval will be a random value between 0.8 and 1.2 (1 second +/- 0.2):\r\n\r\n```ruby\r\nRetriable.retriable base_interval: 1.0, multiplier: 1.0, rand_factor: 0.2 do\r\n  # code here...\r\nend\r\n```\r\n\r\n### Callbacks\r\n\r\n`#retriable` also provides a callback called `:on_retry` that will run after an exception is rescued. This callback provides the `exception` that was raised in the current try, the `try_number`, the `elapsed_time` for all tries so far, and the time in seconds of the `next_interval`. As these are specified in a `Proc`, unnecessary variables can be left out of the parameter list.\r\n\r\n```ruby\r\ndo_this_on_each_retry = Proc.new do |exception, try, elapsed_time, next_interval|\r\n  log \"#{exception.class}: '#{exception.message}' - #{try} tries in #{elapsed_time} seconds and #{next_interval} seconds until the next try.\"}\r\nend\r\n\r\nRetriable.retriable on_retry: do_this_on_each_retry do\r\n  # code here...\r\nend\r\n```\r\n\r\n### Ensure/Else\r\n\r\nWhat if I want to execute a code block at the end, whether or not an exception was rescued ([ensure](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-ensure))? Or, what if I want to execute a code block if no exception is raised ([else](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-else))? Instead of providing more callbacks, I recommend you just wrap retriable in a begin/retry/else/ensure block:\r\n\r\n```ruby\r\nbegin\r\n  Retriable.retriable do\r\n    # some code\r\n  end\r\nrescue => e\r\n  # run this if retriable ends up re-rasing the exception\r\nelse\r\n  # run this if retriable doesn't raise any exceptions\r\nensure\r\n  # run this no matter what, exception or no exception\r\nend\r\n```\r\n\r\n## Kernel Extension\r\n\r\nIf you want to call `Retriable.retriable` without the `Retriable` module prefix and you don't mind extending `Kernel`,\r\nthere is a kernel extension available for this.\r\n\r\nIn your ruby script:\r\n\r\n```ruby\r\nrequire 'retriable/core_ext/kernel'\r\n```\r\n\r\nor in your Gemfile:\r\n\r\n```ruby\r\ngem 'retriable', require: 'retriable/core_ext/kernel'\r\n```\r\n\r\nand then you can call `#retriable` in any context like this:\r\n\r\n```ruby\r\nretriable do\r\n  # code here...\r\nend\r\n```\r\n\r\n## Credits\r\n\r\nRetriable was originally forked from the retryable-rb gem by [Robert Sosinski](https://github.com/robertsosinski), which in turn originally inspired by code written by [Michael Celona](http://github.com/mcelona) and later assisted by [David Malin](http://github.com/dmalin). The [attempt](https://rubygems.org/gems/attempt) gem by Daniel J. Berger was also an inspiration.\r\n","google":"UA-18119942-1","note":"Don't delete this file! It's used internally to help with page regeneration."}